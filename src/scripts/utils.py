# Helper function for getting string inputs to PSQL to work correctly
import datetime
import re
import numpy as np
import logging



def str_psql(x):
    if isinstance(x, str):
        if 'VALUES' not in x and x[0] != '(' and x != 'NULL':
            return "'%s'" % (x,)
    if isinstance(x, list) or isinstance(x, tuple):
        return '(%s)' % ','.join(str(a) for a in x)
    if isinstance(x, datetime.datetime):
        return "TIMESTAMP '%s'" % str(x)
    return str(x)


def str_special(x):
    """
    Convert specific data types to strings for PSQL insertion - leave all others
    untouched
    """
    if isinstance(x, datetime.datetime):
        return x.strftime('%Y-%m-%d %H:%M:%S')
    if isinstance(x, datetime.date):
        return x.strftime('%Y-%m-%d')
    return x


def str_dts(x):
    """
    In a potential SQL string, convert any instances of datetime.date or
    datetime.datetime to their string representation *without* leaving in the
    Python string quotes
    """
    dd = re.compile(r'[\'"]([0-9]{4}\-[01][0-9]\-[0-3][0-9][^\'"]*?)[\'"]')
    return re.sub(dd, 'TIMESTAMP \g<0>', x)


def generate_conditions_string(conditions, combine='AND'):
    """
    Generate a conditions string for use with making PSQL queries.

    Parameters
    ----------
    conditions:
        A list of three-tuples defining conditions, e.g.:
        [(column, condition, value), ...]
        Column must be a table column name. Condition must be a *string* of a
        valid PSQL comparison (e.g. '=', '<=', 'LIKE' etc.). Value should be in
        the correct Python form relevant to the table column.
    combine:
        The method for combining the conditions. Must be a valid SQL comparison.
        Defaults to 'AND'. Can also pass a list of valid SQL comparisons, which
        must have a length of one less than the list of conditions.

    Returns
    -------
    conditions_string:
        The string of PSQL conditions which can be inserted into a query string.
        Note that the string will *not* contain a leading WHERE clause, to allow
        multiple conditions strings (some possibly not generated by this
        function) to be combined more easily.
    """
    allowed_combine = ['AND', 'OR']
    if not isinstance(combine, list):
        combine = [combine] * (len(conditions) - 1)

    if len(conditions) > 0 and (len(combine) != (len(conditions) - 1)):
        raise ValueError('combine must have length of conditions minus 1')

    if np.any([_.upper() not in allowed_combine for _ in combine]):
        raise ValueError('combine values must be any one of: %s' %
                         ', '.join(allowed_combine))
    # combine = ' %s ' % combine

    altered_conditions = []
    for i in range(len(conditions)):
        x = conditions[i]
        if len(x) != 3 and len(x) != 5:
            raise ValueError('Each conditions entry must either be a 3-tuple '
                             '(column, condition, value) or a 5-tuple, where '
                             'the above is wrapped with two strings holding '
                             'either a single bracket, or an empty string for '
                             'no bracket at that position')
        if len(x) == 3:
            x = ('', x[0], x[1], x[2], '')
        altered_conditions.append((x[0],
                                   str(x[1]), str(x[2]), str_psql(x[3]),
                                   x[4]))

    conditions_string = ' '.join(altered_conditions[0])
    for i in range(1, len(altered_conditions)):
        conditions_string += ' %s %s' % (combine[i-1],
                                         ' '.join(altered_conditions[i]))
    # conditions_string = combine.join([' '.join(x)
    #                                   for x in conditions])
    return conditions_string


def generate_having_string(having, having_combine):
    """
    Generate a HAVING clause string for a PSQL query

    Parameters
    ----------
    having :
    having_combine

    Returns
    -------

    """
    allowed_combine = ['AND', 'OR']

    if not isinstance(having_combine, list):
        having_combine = [having_combine] * (len(having) - 1)

    if len(having) > 0 and (len(having_combine) != (len(having) - 1)):
        raise ValueError('combine must have length of conditions minus 1')

    if np.any([_.upper() not in allowed_combine for _ in having_combine]):
        raise ValueError('combine values must be any one of: %s' %
                         ', '.join(allowed_combine))

    altered_conditions = []
    for i in range(len(having)):
        x = having[i]
        if len(x) != 3 and len(x) != 5:
            raise ValueError('Each conditions entry must either be a 3-tuple '
                             '(column, condition, value) or a 5-tuple, where '
                             'the above is wrapped with two strings holding '
                             'either a single bracket, or an empty string for '
                             'no bracket at that position')
        if len(x) == 3:
            x = ('', x[0], x[1], x[2], '')
        altered_conditions.append((x[0],
                                   'bool_and(',
                                   str(x[1]), str(x[2]),
                                   str_psql(x[3]),
                                   x[4],
                                   ')'))

    conditions_string = ' '.join(altered_conditions[0])
    for i in range(1, len(altered_conditions)):
        conditions_string += ' %s %s' % (having_combine[i - 1],
                                         ' '.join(altered_conditions[i]))
    # conditions_string = combine.join([' '.join(x)
    #                                   for x in conditions])
    return conditions_string


def generate_case_string(case):
    """
    UTILITY FUNCTION - generate a single CASE PSQL string
    """
    case_string = 'WHEN %s %s %s THEN %s' % case
    return case_string


def generate_case_conditions_string(conditions, combine='AND'):
    """
    Generate the PSQL string for applying a CASE condition to a query.

    Parameters
    ----------
    conditions:
        Special case-wise conditions. Should be a list of case-wise
        conditions, each taking the following form:
        - A four-tuple containing:
            - The column that the case-wise condition applies to;
            - The comparison operator to be used;
            - A list of 4-tuples, each containing:
                - The column to be checked for this case;
                - The comparison operator to be used for this case;
                - The comparison value to be used for this case;
                - The value to return in this case;
            - The ELSE value to be used.

    Returns
    -------
    conditions_string:
        The string to be inserted into the PSQL statement to enact the
        case-wise condtition.
    """
    # Input checking
    allowed_combine = ['AND', 'OR']
    if len(conditions) == 0:
        return ''
    if not isinstance(combine, list):
        combine = [combine] * (len(conditions) - 1)
    if len(conditions) > 0 and (len(combine) != (len(conditions) - 1)):
        raise ValueError('combine must have length of conditions minus 1')
    if np.any([_.upper() not in allowed_combine for _ in combine]):
        raise ValueError('combine values must be any one of: %s' %
                         ', '.join(allowed_combine))

    altered_conditions = []
    for i in range(len(conditions)):
        x = conditions[i]
        if len(x) != 4 and len(x) != 6:
            raise ValueError('Each conditions entry must either be a 3-tuple '
                             '(column, condition, value) or a 5-tuple, where '
                             'the above is wrapped with two strings holding '
                             'either a single bracket, or an empty string for '
                             'no bracket at that position')
        if len(x) == 4:
            x = ('', x[0], x[1], x[2], x[3], '')
        logging.debug(x)
        if np.any(np.asarray(map(len, x[3])) != 4):
            raise ValueError('Each case tuple must be a 4-tuple')
        altered_conditions.append((x[0],
                                   str(x[1]), str(x[2]), x[3],
                                   str_psql(x[4]), x[5]))
        for i in range(len(altered_conditions[-1][3])):
            altered_conditions[-1][3][i] = (str(altered_conditions[-1][3][i][0]),
                                            str(altered_conditions[-1][3][i][1]),
                                            str_psql(altered_conditions[-1][3][i][2]),
                                            str_psql(altered_conditions[-1][3][i][3]),
                                            )

    conditions_string = ''
    for i in range(len(altered_conditions)):
        if i > 0:
            conditions_string += ' %s' % combine[i-1]
        conditions_string += ' %s %s %s (CASE %s ELSE %s END) %s' % (
            altered_conditions[i][0],
            altered_conditions[i][1],
            altered_conditions[i][2],
            ' '.join([generate_case_string(case) for case in
                      altered_conditions[i][3]]),
            altered_conditions[i][4],
            altered_conditions[i][5]
        )

    return conditions_string


