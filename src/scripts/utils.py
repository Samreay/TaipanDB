# Helper function for getting string inputs to PSQL to work correctly
import datetime
import re
import numpy as np


def str_psql(x):
    if isinstance(x, str):
        if 'VALUES' not in x and x[0] != '(' and x != 'NULL':
            return "'%s'" % (x,)
    if isinstance(x, list) or isinstance(x, tuple):
        return '(%s)' % ','.join(str(a) for a in x)
    if isinstance(x, datetime.datetime):
        return "TIMESTAMP '%s'" % str(x)
    return str(x)


def str_special(x):
    """
    Convert specific data types to strings for PSQL insertion - leave all others
    untouched
    """
    if isinstance(x, datetime.datetime):
        return x.strftime('%Y-%m-%d %H:%M:%S')
    if isinstance(x, datetime.date):
        return x.strftime('%Y-%m-%d')
    return x


def str_dts(x):
    """
    In a potential SQL string, convert any instances of datetime.date or
    datetime.datetime to their string representation *without* leaving in the
    Python string quotes
    """
    dd = re.compile(r'[\'"]([0-9]{4}\-[01][0-9]\-[0-3][0-9][^\'"]*?)[\'"]')
    return re.sub(dd, 'TIMESTAMP \g<0>', x)


def generate_conditions_string(conditions, combine='AND'):
    """
    Generate a conditions string for use with making PSQL queries.

    Parameters
    ----------
    conditions:
        A list of three-tuples defining conditions, e.g.:
        [(column, condition, value), ...]
        Column must be a table column name. Condition must be a *string* of a
        valid PSQL comparison (e.g. '=', '<=', 'LIKE' etc.). Value should be in
        the correct Python form relevant to the table column.
    combine:
        The method for combining the conditions. Must be a valid SQL comparison.
        Defaults to 'AND'. Can also pass a list of valid SQL comparisons, which
        must have a length of one less than the list of conditions.

    Returns
    -------
    conditions_string:
        The string of PSQL conditions which can be inserted into a query string.
        Note that the string will *not* contain a leading WHERE clause, to allow
        multiple conditions strings (some possibly not generated by this
        function) to be combined more easily.
    """
    allowed_combine = ['AND', 'OR']
    if not isinstance(combine, list):
        combine = [combine] * (len(conditions) - 1)

    if len(conditions) > 0 and (len(combine) != (len(conditions) - 1)):
        raise ValueError('combine must have length of conditions minus 1')

    if np.any([_.upper() not in allowed_combine for _ in combine]):
        raise ValueError('combine values must be any one of: %s' %
                         ', '.join(allowed_combine))
    # combine = ' %s ' % combine

    for i in range(len(conditions)):
        x = conditions[i]
        if len(x) != 3 and len(x) != 5:
            raise ValueError('Each conditions entry must either be a 3-tuple '
                             '(column, condition, value) or a 5-tuple, where '
                             'the above is wrapped with two strings holding '
                             'either a single bracket, or an empty string for '
                             'no bracket at that position')
        if len(x) == 3:
            x = ('', x[0], x[1], x[2], '')
        conditions[i] = (x[0], str(x[1]), str(x[2]), str_psql(x[3]), x[4])

    conditions_string = ' '.join(conditions[0])
    for i in range(1, len(conditions)):
        conditions_string += ' %s %s' % (combine[i-1], ' '.join(conditions[i]))
    # conditions_string = combine.join([' '.join(x)
    #                                   for x in conditions])
    return conditions_string
